**905. Sort Array By Parity**
```
Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.

You may return any answer array that satisfies this condition.
```
Example 1:
```
Input: [3,1,2,4]
Output: [2,4,3,1]
The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
```
Note:
```
1. 1 <= A.length <= 5000
2. 0 <= A[i] <= 5000
```

Solution:
```java
class Solution {
    public int[] sortArrayByParity(int[] A) {
        int start = 0, end = A.length - 1;
        while(start < end) {
            while (start < A.length && (A[start] & 1) == 0) {
                start++;
            }
            while (end >= 0 && (A[end] & 1) == 1) {
                end--;
            }
            if (start < end) {
                swap(A, start, end);
                start++;
                end--;
            }
        }
        return A;
    }

    private void swap(int[] A, int i1, int i2) {
        A[i1] = A[i1] ^ A[i2];
        A[i2] = A[i1] ^ A[i2];
        A[i1] = A[i1] ^ A[i2];
    }
}
```
---
**922. Sort Array By Parity II**
```
Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.

Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.

You may return any answer array that satisfies this condition.
```
Example 1:
```
Input: [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
```
Note:
```
1. 2 <= A.length <= 20000
2. A.length % 2 == 0
3. 0 <= A[i] <= 1000
```
Solution:
```java
class Solution {
    public int[] sortArrayByParityII(int[] A) {
        int evenIndex = 0, oddIndex = 1;
        while (evenIndex < A.length && oddIndex < A.length) {
            while (evenIndex < A.length && (A[evenIndex] & 1) == 0) {
                evenIndex += 2;
            }
            while (oddIndex < A.length && (A[oddIndex] & 1) == 1) {
                oddIndex += 2;
            }
            if (evenIndex < A.length && oddIndex < A.length) {
                swap(A, evenIndex, oddIndex);
                evenIndex += 2;
                oddIndex += 2;
            }
        }
        return A;
    }

    private void swap(int[] A, int i, int j) {
        A[i] = A[i] ^ A[j];
        A[j] = A[i] ^ A[j];
        A[i] = A[i] ^ A[j];
    }
}
```
---
**977. Squares of a Sorted Array**
```
Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.
```
Example 1:
```
Input: [-4,-1,0,3,10]
Output: [0,1,9,16,100]
```
Example 2:
```
Input: [-7,-3,2,3,11]
Output: [4,9,9,49,121]
```
Note:
```
1. 1 <= A.length <= 10000
2. -10000 <= A[i] <= 10000
3. A is sorted in non-decreasing order.
```
Solution:
```java
class Solution {
    public int[] sortedSquares(int[] A) {
        int negativeLength = 0;
        while (negativeLength < A.length && A[negativeLength] < 0) {
            negativeLength++;
        }
        int[] B = new int[A.length];
        int bIndex = 0;
        int negativeIndex = negativeLength - 1, positiveIndex = negativeLength;
        while (negativeIndex >= 0 && positiveIndex < A.length) {
            int negativeSquare = A[negativeIndex] * A[negativeIndex];
            int positiveSquare = A[positiveIndex] * A[positiveIndex];
            if (negativeSquare > positiveSquare) {
                B[bIndex++] = positiveSquare;
                positiveIndex++;
            } else {
                B[bIndex++] = negativeSquare;
                negativeIndex--;
            }
        }
        while (negativeIndex >= 0) {
            B[bIndex++] = A[negativeIndex] * A[negativeIndex];
            negativeIndex--;
        }
        while (positiveIndex < A.length) {
            B[bIndex++] = A[positiveIndex] * A[positiveIndex];
            positiveIndex++;
        }
        return B;
    }
}
```
---
**1150. Check If a Number Is Majority Element in a Sorted Array**
```
Given an array nums sorted in non-decreasing order, and a number target, return True if and only if target is a majority element.

A majority element is an element that appears more than N/2 times in an array of length N.
```
Example 1:
```
Input: nums = [2,4,5,5,5,5,5,6,6], target = 5
Output: true
Explanation:
The value 5 appears 5 times and the length of the array is 9.
Thus, 5 is a majority element because 5 > 9/2 is true.
```
Example 2:
```
Input: nums = [10,100,101,101], target = 101
Output: false
Explanation:
The value 101 appears 2 times and the length of the array is 4.
Thus, 101 is not a majority element because 2 > 4/2 is false.
```
Note:
```
1. 1 <= nums.length <= 1000
2. 1 <= nums[i] <= 10^9
3. 1 <= target <= 10^9
```
Solution:
```java
class Solution {
    public boolean isMajorityElement(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return false;
        }
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left + nums.length / 2 < nums.length && nums[left + nums.length / 2] == target;
    }
}
```
---
**896. Monotonic Array**
```
An array is monotonic if it is either monotone increasing or monotone decreasing.

An array A is monotone increasing if for all i <= j, A[i] <= A[j].  An array A is monotone decreasing if for all i <= j, A[i] >= A[j].

Return true if and only if the given array A is monotonic.
```
Example 1:
```

```






